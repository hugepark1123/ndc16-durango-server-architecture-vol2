# Q&A

<dl>

<dt>트랜잭션 문서의 락은 어떻게 관리하나요?</dt>
<dd>
땅문서 트랜잭션 문서 자체는 낙관적 트랜잭션으로 수정합니다.
</dd>

<dt>락을 관리하는 중앙 서버가 있나요?</dt>
<dd>
락을 관리하는 중앙 서비스가 필요한 경우엔 etcd나 Couchbase를 쓸 수 있습니다. 두 가지 모두 분산 서버입니다.
</dd>

<dt>게임 로직 구현할 때 생산성이 괜찮나요?</dt>
<dd>
초반엔 어려움이 있었지만, 분산 구조에 친화적인 게임 로직을 만들기 위한 노하우를 많이 쌓았습니다. 특히 사고의 전환이 필요한 곳이 많았습니다. 최호영 님의 [<야생의 땅: 듀랑고> 중앙 서버 없는 게임 로직](http://www.slideshare.net/hoyoungchoi980/ss-61451757) 발표가 이 질문의 자세한 답변이 될 수 있을 것 같습니다.
</dd>

<dt>트랜잭션 처리가 필요한데 왜 RDB를 안 쓰나요?</dt>
<dd>
RDBMS를 분산하기 난해하기 때문입니다. DB가 SPOF가 되지 않길 바랐고, 또 애플리케이션이 직접 DB를 샤딩하게 하고 싶지 않았습니다.
</dd>

<dt>서비스가 오래되면 트랜잭션 문서가 지나치게 커지지 않을까요?</dt>
<dd>
트랜잭션 문서 하나는 최대 16개의 태스크밖에 담지 않습니다. 태스크는 서버 노드가 땅문서를 읽을 때마다 처리되므로 잔존 태스크가 지나치게 많아질 일은 없습니다.
</dd>

<dt>트랜잭션 처리가 지연되어 청크 락 TTL 이후에 땅문서 수정이 이뤄지면 어떻게 되나요?</dt>
<dd>
락은 해당 청크에 추가적인 태스크가 등록되지 않게 하기 위한 것으로, 실제 데이터 수정은 청크 락이 풀린 상태에서 이뤄집니다.
</dd>

<dt>SPOF가 없는지 어떻게 검증하고 있나요?</dt>
<dd>
일부 게임 서버 노드가 죽는 시나리오를 부분적으로는 유닛테스트로 검증하고 있습니다. 늘 하는 건 아니지만, 일부 노드를 끄고 켜는 테스트도 하고 있습니다.
</dd>

<dt>듀랑고의 섬이 다른 게임의 채널과 같지 않나요?</dt>
<dd>
채널은 같은 장소에서 동기화 위상을 달리하는 기능입니다. 섬은 아예 다른 장소입니다. 다른 게임의 존에 더 가까울 것 같습니다.
</dd>

<dt>섬에서 섬으로 이동할 때도 로딩이 없나요?</dt>
<dd>
있습니다.
</dd>

<dt>낙관적 트랜잭션 재시도가 계속 실패해서, 플레이어에게 일부만 적용된 상태로 보이는 경우는 전혀 없나요?</dt>
<dd>
낙관적 트랜잭션은 단 한 레코드에 한해서만 쓸 수 있습니다. 따라서 수정사항이 일부만 적용될 수는 없습니다.
</dd>

<dt>시설물을 설치할 때 땅의 정보 뿐 아니라 설치한 플레이어의 정보도 변화시키는 경우가 많은데, 이 부분에 대해서도 트랜잭션을 보장하나요?</dt>
<dd>
트랜잭션이 중요한 부분이라면 BASE 트랜잭션을 이용할 수 있습니다만, 모든 경우에서 일관성을 추구하진 않습니다. 발표에서 소개해드린 땅문서는 정적 객체와 타일 간 연결의 일관성만 보장해줍니다.
</dd>

<dt>클라이언트에서도 ZeroMQ를 사용하나요?</dt>
<dd>
클라이언트에서는 사용하지 않습니다.
</dd>

<dt>노드 시야가 겹치는 영역에서 인터렉션이 빈번하면 동기화 부하가 커질 것 같은데 서버 처리 속도가 느려지진 않나요?</dt>
<dd>
맞습니다. 그래서 동기화 성능이 주요한 최적화 대상이며, 로드밸런싱의 목적도 한 장소를 너무 많은 서버 노드가 관여하지는 않도록 하는 것입니다.
</dd>

<dt>플레이어 위치의 최소 단위가 타일이고, 클라이언트에서 타일 좌표가 바뀔 때마다 서버와 통신하나요?</dt>
<dd>
플레이어 객체는 타일보다 작은 단위에서 자유롭게 움직입니다. 클라이언트는 주기적으로 서버에 현재 좌표 대신 지나온 길을 보냅니다.
</dd>

<dt>어떤 Couchbase 버전을 사용하시나요? 그 이유는?</dt>
<dd>
4.1.0을 쓰고 있습니다. 최신 릴리즈니까요.
</dd>

<dt>섬과 객체가 잠재적으로 무한해도 부하가 발생하는 한계는 있을텐데, 듀랑고의 최대 수용 인원은 어느정도인가요?</dt>
<dd>
활성화된 섬과 객체는 현재 떠 있는 게임 서버 노드에 의해 수용되지만, 그 밖에 자고 있는 섬과 객체는 DB에 의해 수용됩니다. 어느 지점이든 한계에 도달하면 분산시키는 것만으로 수용력을 높이는 것이 저희의 목표입니다. 너무 많은 노드가 떠서 오버헤드가 발생할 수 있는데, 이 부분을 최소화하려고 노력하고 있습니다.
</dd>

<dt>ZeroMQ에 연결됨/끊김 이벤트가 없다고 들었는데 어떻게 처리하셨나요?</dt>
<dd>
ZeroMQ 3.2에 추가된 모니터 소켓으로 연결됨/끊김 이벤트를 받아볼 수 있습니다.
</dd>

<dt>Couchbase나 etcd를 분산 락 프리미티브로 사용할 때 지연이 감내할 만한 수준인가요? 낮은 레이턴시를 요구하는 콘텐츠에도 쓸 수 있을까요?</dt>
<dd>
감내할 만 하다고 생각합니다. 하지만 저희는 낮은 레이턴시를 추구하지 않습니다. 낮은 레이턴시가 반드시 필요한 게임에선 다른 접근이 필요할 것 같습니다.
</dd>

<dt>Dirty read 문제는 어떻게 해결하나요?</dt>
<dd>
땅문서를 읽을 때 잔존 수정사항이 있으면 처리합니다. 수정에 실패하면 땅문서 읽기도 실패합니다.
</dd>

<dt>서버 노드 장애를 감지해 다른 노드로 역할을 넘겨주는 서비스가 있나요?</dt>
<dd>
별도의 서비스는 없습니다. 대신 모든 게임 서버 노드가 클러스터의 상태와 적합한 노드를 찾는 로직을 공유합니다. 특정 노드에 장애가 생기면 그곳에 있던 객체들은 적합한 노드에 다시 유입됩니다.
</dd>

<dt>노드를 기능별로 잘게 쪼갠 이유가 뭔가요?</dt>
<dd>
- 개발할 때 관여할 영역을 제한해 생산성을 높이고 싶었습니다.
- 기능별로 로드밸런싱 방법이 다릅니다. 일부는 청크 좌표에 기반하지만 콜로세움 같은 경우는 Round-robin 방식을 쓰죠. 로드밸런싱 방법에 차이를 주기 편합니다.
- 기능별로 부하가 분리됩니다. 문제가 생겼을 때 보다 쉽게 파악할 수 있고, 기능별 증설/감축에 용이합니다.
</dd>

<dt>섬마다 인구밀도로 플레이어의 접속을 제한하고 있는 건가요?</dt>
<dd>
유입을 조정하기만 하고, 접속을 제한하진 않습니다.
</dd>

<dt>활성화된 객체가 다시 신기루가 될때 DB에서도 제거하나요?</dt>
<dd>
객체 종류에 따라 다릅니다. 영원히 남기도 하고, 일정 시간 동안만 남기도 하고, 아예 저장되지 않을 수도 있습니다.
</dd>

<dt>발표 자료에 쓰인 삽화는 직접 그린 건가요?</dt>
<dd>
그렇습니다.
</dd>

</dl>
