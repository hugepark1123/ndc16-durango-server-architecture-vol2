# <야생의 땅: 듀랑고> 서버 아키텍처 Vol. 2

<야생의 땅: 듀랑고>는 광활한 땅을 개척하며 풍성한 생태계 속 생활을 즐기는 모바일 MMORPG입니다. 듀랑고 세계의 수많은 섬들은 플레이어의 행동 하나하나에 반응해 영구적으로 변화합니다. <마비노기 영웅전>처럼 서버군 구분이 없고, 나아가 채널 구분도 없어서 가까운 장소에 있는 모든 플레이어와 서로 만날 수 있습니다. 듀랑고 서버 아키텍처는 이런 듀랑고를 지탱하기 위해 "무한한 공간", "영속적 세계", "단일 채널", "고 가용성" 등을 목표로 도전하고 있습니다.

전 넥슨 왓 스튜디오의 서비스파트장 이흥섭입니다. 듀랑고의 서버 아키텍처를 담당하는 한편 틈틈이 오픈소스 활동을 하고 있습니다.

## 멀리 보기

### SPOF 배제

프로젝트 초기부터 지금까지 저희의 목표는 SPOF 없는 MMORPG 서버를 만드는 것이었습니다. SPOF는 "Single Point of Failure"의 약자로 보통 "단일장애지점"으로 번역하는데, 문제가 발생하면 서비스 전체의 장애를 초래하는 한 지점을 뜻합니다. 단 하나의 서비스 요소라도 이중화되어 있지 않다면 그곳은 SPOF라고 볼 수 있습니다.

저희는 SPOF가 생기지 않게 하고자 모든 요소를 이중화하려고 노력해왔습니다. 우선 중앙서버의 중계 없이도 게임서버 노드끼리 통신시키기 위해 ZeroMQ를 도입했습니다. 모든 게임서버 노드는 서로 N:N 연결을 맺고 동등한 위상에서 동기화 메시지를 주고받습니다. 그러려면 한 노드가 다른 노드의 주소를 자동으로 알아낼 수 있어야 하는데, 이 부분에서 Apache ZooKeeper 같은 컨센서스 코디네이터인 etcd의 도움을 받습니다. 데이터베이스로는 RDBMS 대신 NoSQL DBMS인 Couchbase를 채택했으며, 손쉽게 서버를 증설하거나 감축하기 위해 AWS를 이용하고 있습니다.

### 역할 별 게임서버 노드

게임서버 노드는 몇 가지 역할로 나뉘어있습니다.

1. 프론트엔드 - 게임 클라이언트가 직접 접속합니다. 플레이어 객체를 관리하고 주변 상황을 클라이언트에 스트리밍합니다.
2. 게이트웨이 - 로그인과 자원 접근을 담당하는 RESTful한 웹 서버입니다. 클라이언트가 접속할 프론트엔드가 여기서 정해집니다.
3. 동물원 - 동물을 시뮬레이션합니다.
4. 정원 - 식물, 광물, 시설물같이 정적인 객체를 관리합니다.
5. 콜로세움 - 전투를 처리합니다.

### 게임서버의 시야

일부 게임서버 노드는 게임세계 곳곳에 흩어져있는 객체의 소유권을 얻고 전담하여 관리합니다. 이때 같은 노드가 관리하는 객체라 해도 꼭 같은 장소에 모여있는 것은 아닙니다. 노드가 객체를 전담할 때 객체의 위치에는 제한을 두지 않습니다.

객체는 저마다 시야를 갖고, 게임서버 노드 또한 시야를 갖습니다. 한 노드가 전담하는 모든 객체의 시야를 더한 영역을 그 노드의 시야로 삼습니다. 게임서버 노드끼리 시야가 겹치면, 다른 노드에서 전담하던 객체가 프록시 객체로 동기화됩니다. 이런 방식으로 각자가 관리하는 객체 근처의 세계를 인지하고 중계하고 상호작용합니다.

### 정리

이처럼 SPOF가 생기지 않게 하고자 모든 서비스 요소를 이중화하는 한편, 모든 서버 노드가 유기적으로 협력해 단 하나의 듀랑고 세계를 구축하도록 설계하고 있습니다.

이렇게 만들어진 게임서버가 듀랑고라는 게임을 어떻게 구현하고 있는지, 자세히 들여다보겠습니다.

## 들여다보기

### 부동산

#### 군도

듀랑고에서 "섬"은 심리스하게 이동할 수 있는 공간적 단위입니다. 개발 초기엔 단 하나의 거대한 대륙을 기획했으나 개발을 진행하면서 여러 섬을 넘나드는 군도 모델로 선회하게 되었습니다. 군도에는 안정섬과 불안정섬, 두 종류의 섬이 있습니다. 안정섬에선 좋은 자원이 나지 않지만, 면적이 넓고 사라지지 않아 정착하여 마을을 구성하기 좋습니다. 반면 불안정섬은 면적이 좁고 일정한 시간이 지나면 사라지지만, 생태계도 훨씬 다양하고 좋은 자원도 구할 수 있어 탐험하는 데 적합합니다.

각 섬의 적정 인구밀도를 맞추기 위해, 플레이어 수에 맞춰 섬의 수가 조절됩니다. 100명만 플레이할 때 섬은 서너 개밖에 되지 않지만, 10,000명이 플레이할 때엔 수백 개의 섬이 생길 수 있습니다. 지난 2차 리미티드 베타 테스트를 예로 들면, 참여자 약 7천 명을 위해 836개의 섬이 만들어졌었습니다.

이처럼 듀랑고 세계의 공간은 잠재적으로 무한합니다. 게임서버는 얼마나 늘어날지 모르는 공간을 지탱해야 합니다. 그럼 어떤 방식으로 잠재적으로 무한한 공간을 처리하는지 살펴보겠습니다.

#### 청크와 땅문서

플레이어가 게임에 접속할 땐 우선 자신의 아이디를 게이트웨이에 알려줍니다. 게이트웨이는 플레이어가 로그아웃했던 마지막 위치를 기반으로 접속할 프론트엔드를 배정해줍니다. 이어서 클라이언트가 배정받은 프론트엔드에 접속하면 플레이어 객체가 게임세계에 나타나게 됩니다.

플레이어는 접속했을 때에만 게임세계에 속하므로, 서버는 수동적으로 그저 요청받은 플레이어를 DB에서 찾기만 하면 됩니다. 반면 식물, 광물, 시설물 같은 정적객체는 늘 게임세계에 속해있습니다. 그렇다고 플레이어처럼 스스로 서버에 접속하는 것은 아니기에 서버가 직접 찾아내야 합니다. 그러려면 아이디로 색인되는 플레이어와 달리 정적객체는 위치로 색인되어야 합니다.

서버에서 위치를 다룰 땐 몇 가지 간략화된 지리적 단위를 이용합니다. 섬의 모양새인 "지형"은 한 장의 타일맵인데 "타일"은 게임 내에서 정적객체가 점유할 수 있는 영역의 최소 단위입니다. 타일을 16×16씩 묶은 구역은 "청크"라고 부릅니다. 청크는 섬에 상관없이 크기가 일정하면서도 규모가 적당해서 다양한 경우에서 유용하게 쓰입니다.

한편, 키-밸류 스토리지인 Couchbase에서 아이디 이외의 단서로 데이터를 찾는 것은 간단하지 않습니다. Map/Reduce를 지원하긴 하지만 색인 속도가 느려서 잦은 조회와 갱신에는 적합하지 않습니다.

저희는 Couchbase를 쓰면서도 정적객체의 위치를 빠르고 정확하게 색인하기 위해, "땅문서"라고 부르는 별도의 문서에 위치 정보를 역정규화(denormalization)했습니다. 단순하게 어느 타일에 어떤 정적객체가 위치하는지 가리키는 딕셔너리라고 볼 수 있습니다. 땅문서는 청크마다 하나씩 존재합니다. 섬 전체를 하나의 땅문서로 관리할 경우 섬 크기에 따라 색인 부담도 함께 커지기 때문에 크기가 일정한 청크 단위로 조각냈습니다.

#### 땅문서 트랜잭션

땅문서는 어떤 서버 노드에서든 조회하고 수정할 수 있습니다. 따라서 여러 스레드가 동시에 수정하려 할 때 덮어쓰지 않도록 보호해야 합니다. 개발 초기엔 "낙관적 트랜잭션" 기법을 사용했습니다. 조회할 때 문서 버전을 함께 받고 수정할 때 버전이 바뀌지 않았는지 확인해서, 조회와 수정 사이에 다른 수정사항이 없었을 경우에만 수정을 수행하는 방법입니다. 만약 버전이 바뀌었을 경우 DB가 수정하길 거부하는데, 이땐 문서를 다시 조회한 후 수정을 재시도합니다. 이 과정을 반복하다 보면 언젠가는 경합이 끝나게 되어, 한 문서에 한해 트랜잭션을 보장할 수 있습니다.

설치하려는 객체가 한 청크 안에 쏙 들어갈 때는 수정할 땅문서도 한 개라서 낙관적 트랜잭션만으로도 충분하지만, 객체가 여러 청크에 걸친 경우에는 그렇지 않습니다. Couchbase가 여러 문서에 대한 쓰기 트랜잭션을 보장해주지 않기 때문입니다. 게임서버가 한 번에 여러 땅문서를 차례대로 수정하면, 서버 버그나 쓰기 경합 같은 상황에서 불완전한 땅문서가 만들어질 수 있습니다. 이럴 때에도 땅문서를 안전하게 관리하기 위해 "BASE 트랜잭션"을 기반으로 여러 땅문서의 트랜잭션을 보장할 방법을 고안했습니다.

BASE 트랜잭션은 RDB의 "ACID 트랜잭션"에 대응하는 NoSQL 식 접근법으로, DB가 아닌 애플리케이션이 여러 문서에 대한 트랜잭션을 보장하는 방법입니다. BASE 트랜잭션에서는 여러 문서를 직접 수정하는 대신, 먼저 작업내용을 별개의 문서에 기록해놓고 수정할 문서들은 차근차근 수정해 나갑니다. 언젠가(Eventually) 모든 문서에 해야 하는 일이 적용되면 트랜잭션이 완료된 것입니다.

땅문서를 수정할 때에도 BASE 트랜잭션과 마찬가지로 별개의 트랜잭션 문서에 수정사항을 기록합니다. 한 트랜잭션 문서는 4×4 청크를 담당하는데 이웃한 트랜잭션 문서와 서로 1청크씩 겹쳐있습니다. 정적객체가 아무리 커도 한 청크를 넘지는 않기 때문에, 어느 곳에 있더라도 단 하나의 트랜잭션 문서로 완전히 포갤 수 있습니다.

BASE 트랜잭션을 쓰면 문서 롤백에 대비해야 합니다. A 문서를 성공적으로 수정했는데 B 문서를 수정하는 데엔 실패한다면, 역함수를 실행해 A 문서에 적용됐던 수정사항을 다시 되돌려야 합니다. 그런데 역함수를 구현하기 어려운 경우도 있고 역함수마저 실패할 수도 있습니다. 게다가 A 문서를 성공적으로 수정하고 나서 B 문서가 실패한다는 것을 알 수 있기까지 시간이 오래 걸릴 가능성도 있습니다. 이처럼 신경 써야 할 예외 상황이 많아서 BASE 트랜잭션은 다루기 까다로운 편이라고 생각합니다.

저희는 땅문서 트랜잭션에서 롤백의 가능성을 없애기 위해 비관적 트랜잭션을 접목해 청크 잠금을 도입했습니다. 땅문서 트랜잭션을 등록할 땐 반드시 이 잠금을 획득해야 합니다. 이미 잠겨있다면 바로 트랜잭션을 포기합니다. 잠금엔 짧은 TTL이 설정되어 있어 게임서버 오류로 인해 잠금이 제때 풀리지 않더라도 괜찮습니다.

게임서버가 땅문서를 수정할 땐 우선 청크들을 잠그고, 조건을 검사하고, 수정사항을 트랜잭션 문서에 등록하고, 잠금을 풀고, 마지막으로 등록했던 수정사항을 처리합니다. 이때 일부 수정사항이 성공적으로 처리되지 못하더라도 다른 스레드에서 해당 땅문서를 읽을 때 다시 처리되게 됩니다.

이로써 땅문서를 수정하는 일련의 과정 중 어느 순간에 실패가 발생하더라도, 수정사항은 온전히 성공하거나 찌꺼기를 남기지 않고 깨끗이 실패합니다. 한 번 케이스 별로 살펴보겠습니다:

1. 청크를 잠그다 실패한다. → 거부
2. 조건에 부합하지 않는 수정사항이다. → 잠금을 풀고 거부
3. 수정사항을 등록하는 데 실패한다. → 잠금을 풀고 거부
4. 잠금을 푸는 데 실패한다. → 잠금은 짧은 TTL 이후에 자동으로 풀린다.
5. 방금 등록한 수정사항을 처리하는 데 실패한다. → 다른 스레드가 땅문서를 불러올 때 처리된다.

#### 정리

크기가 균일한 청크와 청크 별로 저장되는 땅문서로 정적객체를 어떻게 다루는지 살펴봤습니다. 듀랑고에서 부동산은 가장 중요한 자원인 만큼 안전한 방법으로 관리하고 있습니다. 이어서 듀랑고 세계의 객체들이 언제 생성되고 언제 서버 메모리에 올라오는지 이야기해보겠습니다.

### 신기루

섬은 공간만 차지하는 것이 아니라 수많은 객체도 포함하고 있습니다. 나무, 바위, 시설물 같은 정적객체도 잔뜩 배치되고, 여기저기에 동물도 서식합니다. 지난 2차 리미티드 베타 테스트의 경우 정적객체 300만 개와 동물 10만 마리가 동원되었습니다. 이 모든 객체를 서버 메모리에 항상 올려두는 것은 불가능할 것입니다.

제가 한동안 빠져있었던 \<GTA5>는 방대한 도시를 제공하는 심리스 오픈월드 게임입니다. 게임의 배경인 산 안드레아스는 수많은 NPC로 채워져 있습니다. 걸어 다니는 행인부터 절 잡으러 오는 경찰들이나 도로를 빽빽이 채우는 자동차들까지. 얼마나 많은 NPC와 정교한 AI가 산 안드레아스를 채우고 있을지 상상하기 어렵습니다. 하지만 이렇게 구체적인 NPC는 사실 제 근처의 좁은 구역에만 있었습니다. 저 멀리 고속도로를 달리는 자동차들은 아무것도 판단하지 않고 그저 정해진 패턴만 반복하는 하얗고 붉은 빛덩이일 뿐입니다.

컴퓨터 그래픽스에서 LOD(Level of Detail)는 카메라에서 먼 객체를 대충 렌더링하는 최적화 기법입니다. \<GTA5>는 NPC에 LOD를 적용하고 있습니다. 바로 근처의 NPC는 매우 정교하게 동작하지만, 거리가 멀수록 단순한 패턴만 반복합니다. \<GTA5> 뿐 아니라 \<어세신크리드 유니티>도 그렇고, 여러 심리스 오픈월드 게임들이 비슷한 방식을 취합니다.

저희도 수많은 객체를 효율적으로 처리하기 위해 LOD를 적용했습니다. 정적객체를 위한 LOD는 거리가 아닌 상호작용 여부에 반응하게 했습니다. 이들은 플레이어가 건드려야만 활성화되어 서버 메모리에 올라갑니다. 그 전까진 표시를 위한 최소한의 정보로만 땅문서에 존재하는데 저희는 이 상태를 "신기루"라고 부릅니다. 신기루 상태에서도 클라이언트에 표시되고, 서버에서도 존재를 인식할 수 있습니다. 플레이어에 의해 활성화된 정적객체는 일정 시간 동안 플레이어와 상호작용하다가 다시 신기루가 됩니다.

나무와 바위 같은 자연물은 섬이 생성될 때부터 함께 존재해야 합니다. 섬을 생성할 때 자연물도 함께 생성해서 일일이 DB에 저장한다면, 섬 생성 속도가 느려져서 필요에 따라 섬을 실시간으로 늘리기 어려울 것입니다.

재료에 따라 생김새가 달라지는 시설물과 달리, 자연물은 생김새가 판에 박혀있어 숫자 하나만으로도 표현할 수 있습니다. 섬의 최초 자연물 배치는 단순한 숫자맵 파일로 지형패키지에 포함했습니다. 섬이 새로 생성된 직후엔 DB에 땅문서가 존재하지 않는데, 땅문서 대신 이 파일을 읽어서 신기루 자연물을 보여줍니다. 신기루 자연물은 플레이어가 건드렸을 때야 비로소 객체로 만들어지고 DB에 저장됩니다. 이때 그곳의 땅문서도 함께 생성되어 DB에 저장됩니다. 이후엔 파일 대신 DB에 있는 땅문서를 참조합니다.

동물은 성능을 많이 요구하는 고수준 AI를 돌리기 때문에 특히 효율적으로 관리해야 합니다. 여기에는 \<GTA5>처럼 거리에 반응하는 LOD를 적용했습니다. 섬 여기저기엔 동물의 서식지가 기록돼있고, 플레이어는 이동하면서 시야에 들어온 서식지의 동물들을 깨웁니다. 깨어난 동물은 고수준 AI를 돌리면서 주변 환경과 상호작용하고 생태계를 연출합니다. 동물의 활동은 근처에 관객이 있는 동안에만 지속됩니다. 관객이 사라지면 마지막 상태를 DB에 기록한 후 모두 사라집니다.

이처럼 듀랑고에선 수많은 객체가 플레이어의 눈앞을 빽빽이 채우고 있지만, 대부분은 신기루 상태로 컴퓨팅 자원이나 DB 공간을 소모하지 않습니다. 듀랑고의 잠재적으로 무한한 공간을 지탱하기 위해 서버는 언제나 플레이어가 필요로 하는 곳에만 자원을 집중하고 있습니다.

신기루나 앞서 소개한 부동산을 게임로직에서 실제로 다룬 사례를 오늘 오후 2시 10분, 최호영 님 발표에서 소개합니다. 중앙서버가 없는 환경에서 게임로직을 구현하는 데에 있어 어떤 난관이 있었고 어떻게 극복했는지 공유하는 자리입니다. 이어서 듣길 추천합니다.

이번엔 주제를 바꿔 듀랑고의 전투에 관해 이야기해보겠습니다.

### 전투 공방 합

개발 초기에 듀랑고의 전투는 프론트엔드와 동물원에 걸쳐서 벌어졌습니다. 양쪽에서 플레이어 객체와 동물 객체가 서로 주거니 받거니 하며 싸우는 것이죠. 따라서 언제나 모든 리액션이 지연될 수 있었습니다. 플레이어가 동물을 때리기로 해서 공격 연출을 내보냈는데, 동물이 제때 맞아주지 않아 피격 판정이 어긋나는 경우가 발생하곤 했습니다.

공방 합을 맞추기 위해 새로운 게임서버 노드인 콜로세움을 도입했습니다. 전투가 벌어지면 임의의 콜로세움에 전투 방이 생성되고, 그때부터 전투 참여자 객체가 콜로세움에 동기화됩니다. 콜로세움은 동기화된 객체를 소유하진 않지만, 제어권을 넘겨받습니다. 전투 방에는 전투 스케줄러가 도는데 전세를 파악하여 공방 계획을 세우는 역할을 합니다. 이렇게 세워진 공방 계획이 프론트엔드와 동물원에 통보됩니다.

공방 계획은 콜로세움 하나에서 모두 결정되기 때문에 판정에서의 공방 합은 언제나 맞게 되었습니다. 이렇게 미리 합을 맞춘 공방 계획을 하나의 패킷으로 묶어 클라이언트로 전달하면 연출에서도 공방 합을 맞출 수 있을 것입니다…만 아직 이 계획은 실현하지 못했습니다. 현재 전투 중 동물의 행동은 콜로세움에서 동물원을 거쳐 프론트엔드로 전달되고, 플레이어의 행동과 다른 시점에 클라이언트로 전달됩니다. 그래서 공격 연출과 방어 연출에 시간차가 발생할 수 있는데, 이 부분은 앞으로 개선될 예정입니다.

저희가 설계한 분산 서버 아키텍처로 처리 규모와 가용성을 높일 수 있었지만, 서버 노드 간 합의가 필요한 경우엔 간단한 일이라도 우회 책을 마련할 필요가 있었습니다. 무한히 넓은 듀랑고 세계를 만들기 위한 트레이드오프로 인식하고 있으며, 조금 더 쉽게 해결하는 방법과 장치를 꾸준히 고민하고 있습니다.

콜로세움 전투의 더 자세한 이야기는 오늘 오후 3시 20분 박동일 님 발표에서 들으실 수 있습니다.

### 정리

지금까지 저희 게임서버가 듀랑고라는 게임을 어떻게 구현하고 있는지 살펴봤습니다. 크기가 균일한 청크와 필요한 곳에만 자원을 집중하는 LOD 처리로 잠재적으로 무한한 공간을 지탱하고, 안전하게 관리되는 땅문서와 콜로세움같이 특화된 서버 노드로 모든 서버 노드가 합의한 단 하나의 게임세계를 만들었습니다.

## 돌아보기

아직은 서버 아키텍처에 미흡한 부분 많습니다. 두 차례의 리미티드 베타 테스트를 진행하면서 겪은 주요 문제 두 가지를 꼽아봤습니다.

하나는 로드밸런싱 문제로, 프론트엔드의 부하가 고르게 분배되지 않던 점입니다. 많은 사람이 좁은 지역에 밀도 높은 마을을 형성하여 모여 살기 때문이었습니다. 플레이어의 위치로만 프론트엔드를 배정해서는 특정 프론트엔드에 부하가 몰려 동기화 품질이 떨어지는 것을 막을 수 없었습니다. 배정할 때 지역뿐 아니라 부하 상황도 고려하도록 개선하려고 합니다.

나머지 하나는 불안정섬 과잉공급 문제입니다. 불안정섬이 하나만 생겨도 그곳엔 발견 가능한 동물이 수십 마리는 딸려오는데, 면적이 좁아서 몇 안 되는 플레이어만 돌아다녀도 대부분의 동물이 깨어나게 됩니다. 많은 동물이 바쁘게 움직이면 동물원에도 부하가 생기고 프론트엔드에도 동기화 부담이 가중될 수 있습니다. 불안정섬의 적정 인구밀도를 조절해 이런 문제를 해결할 수 있을 거라 생각했지만, 이번에 설정한 인구밀도로는 동시 접속자에 비해 불안정섬이 지나치게 많아졌었습니다. 동기화 성능과 인구밀도 조절법을 함께 개선해야 할 것 같습니다.

모든 문제가 해결된 상태는 아니었지만, 테스트를 성공적으로 마칠 수 있었던 까닭은 서버 증설과 감축, 재시작에 자유로웠다는 점에 있었습니다. 각 게임서버 노드가 특정 영역을 독점하는 것이 아니기에, 문제가 발생한 노드를 종료하면 다른 노드들이 바로 그 역할을 대신합니다. 동물원의 경우 몇몇 노드가 폭주하는 버그가 있었는데 재시작하는 것만으로 점검 없이 문제를 해결할 수 있었습니다. 서버 부하가 높아졌을 때에도 새로운 노드를 띄우는 것으로 부하를 분산해 서비스를 중단하지 않고 상황을 회복시켰습니다. 이런 구조와 운영 경험을 토대로 나중엔 듀랑고 서버를 오토스케일링할 수 있는 MMORPG 서버로 만들고자 합니다.

개인적으로 아쉬운 베타 테스트였지만 저희 서버 아키텍처의 약점과 강점을 파악할 좋은 기회였습니다. 이것을 발판 삼아 다음번에 더 좋은 서비스를 제공하도록 준비하고 있습니다.

## 마무리

저희 왓 스튜디오에선 함께 교류할 훌륭한 인재를 찾아다니고 있습니다. 저와 함께 듀랑고의 흥하는 서버를 만들고 싶으신 분, 혹은 아이디어를 주고받고 싶으신 분은 제게 연락주세요.

감사합니다.